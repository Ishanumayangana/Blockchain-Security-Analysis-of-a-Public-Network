# %% [markdown]
# # Module 2: Smart Contract Vulnerability Detection
# This notebook uses Machine Learning (Random Forest) to classify smart contracts as vulnerable or safe based on static analysis features.

# %%
import sys
sys.path.append('..') 

from src.attacks.contract_vuln import generate_synthetic_contract_data, train_vulnerability_classifier, plot_feature_importance
from src.utils import setup_plotting_style
import seaborn as sns
import matplotlib.pyplot as plt

setup_plotting_style()

# %% [markdown]
# ## 1. Generate Dataset
# We simulate a dataset of extracted contract features.
# Features include:
# - `has_external_call`: Checks if contract makes external calls.
# - `state_change_after_call`: Checks for Check-Effects-Interaction pattern violation.
# - `no_reentrancy_guard`: Checks for modifiers like `nonReentrant`.

# %%
df = generate_synthetic_contract_data(n_samples=2000)
print(df.head())
print(f"Vulnerable contracts ratio: {df['vulnerable'].mean():.2%}")

# %%
# Visualizing correlations
plt.figure(figsize=(8, 6))
sns.heatmap(df.corr(), annot=True, cmap='coolwarm')
plt.title("Feature Correlation Matrix")
plt.show()

# %% [markdown]
# ## 2. Train Model
# We train a Random Forest classifier.

# %%
model, X_test, y_test, y_pred = train_vulnerability_classifier(df)

# %% [markdown]
# ## 3. Feature Importance
# Which features were most predictive of vulnerability?

# %%
plot_feature_importance(model, X_test.columns)

# %% [markdown]
# ## 4. Prediction Example
# Let's test on a custom "contract".

# %%
import pandas as pd
# Hypothetical contract: Calls external user, updates balance AFTER call, has no guard.
risky_contract = pd.DataFrame([{
    'has_external_call': 1,
    'state_change_after_call': 1,
    'no_reentrancy_guard': 1,
    'uses_delegatecall': 0,
    'code_complexity': 50
}])

prob = model.predict_proba(risky_contract)[0][1]
print(f"Vulnerability Probability: {prob:.4f}")
if prob > 0.5:
    print("ALERT: High Risk of Reentrancy!")
else:
    print("Contract seems safe.")
